<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="YmsCoreBluetooth : A framework for working with CoreBluetooth. Includes Deanna, an iOS application using YmsCoreBluetooth to communicate with a TI SensorTag." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>YmsCoreBluetooth</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/kickingvegas/YmsCoreBluetooth">View on GitHub</a>

          <h1 id="project_title">YmsCoreBluetooth</h1>
          <h2 id="project_tagline">A framework for working with CoreBluetooth. Includes Deanna, an iOS application using YmsCoreBluetooth to communicate with a TI SensorTag.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/kickingvegas/YmsCoreBluetooth/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/kickingvegas/YmsCoreBluetooth/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="ymscorebluetooth-094-beta" class="anchor" href="#ymscorebluetooth-094-beta"><span class="octicon octicon-link"></span></a>YmsCoreBluetooth 0.94 (beta)</h1>

<p>A framework for building Bluetooth 4.0 Low Energy (aka Smart or LE) iOS or OS X applications using the CoreBluetooth API. Includes <em>Deanna</em> and <em>DeannaMac</em>, applications to communicate with a <a href="http://processors.wiki.ti.com/index.php/Bluetooth_SensorTag">TI SensorTag</a> for iOS and OS X respectively.</p>

<ul>
<li><a href="http://kickingvegas.github.io/YmsCoreBluetooth/appledoc/index.html">YmsCoreBluetooth API Reference</a></li>
</ul><h2>
<a name="ymscorebluetooth-design-intent-or-why-you-want-to-use-this-framework" class="anchor" href="#ymscorebluetooth-design-intent-or-why-you-want-to-use-this-framework"><span class="octicon octicon-link"></span></a>YmsCoreBluetooth Design Intent: Or Why You Want To Use This Framework</h2>

<h3>
<a name="tldr" class="anchor" href="#tldr"><span class="octicon octicon-link"></span></a>tl;dr</h3>

<ul>
<li>ObjectiveC Block-based API for Bluetooth LE communication.</li>
<li>Operations (e.g. scanning, retrieval, connection, reads, writes) map to the data object hierarchy of CoreBluetooth.</li>
<li>You can build apps using CoreBluetooth <a href="http://yummymelon.com/ymsblog/sensortag-remote-control-for-itunes.html">faster</a>.</li>
</ul><h3>
<a name="a-more-detailed-explanation" class="anchor" href="#a-more-detailed-explanation"><span class="octicon octicon-link"></span></a>A More Detailed Explanation</h3>

<h4>
<a name="blocks-are-cool" class="anchor" href="#blocks-are-cool"><span class="octicon octicon-link"></span></a>Blocks are cool.</h4>

<p>Transactions in Bluetooth LE (BLE) are two-phase (request-response) in nature: CoreBluetooth abstracts this protocol so that request behavior is separated from response behavior. The two phases are reconciled using a delegation pattern: the object initiating the request phase has a delegate object with a delegate method to handle the corresponding response phase. While functional, the delegation pattern can be cumbersome to use because the behavior for a two-phase transaction is split into two different locations in code.</p>

<p>A more convenient programming pattern is to use a callback block which is defined with the request. When the response is received, the callback block can be executed to handle it. <em>The design intent of YmsCoreBluetooth is use Objective-C blocks to define response behavior to BLE requests</em>. Such requests include:</p>

<ul>
<li>scanning and/or retrieving peripheral(s)</li>
<li>connecting to a peripheral</li>
<li>discovering a peripheral's services</li>
<li>discovering a service's characteristics</li>
<li>write and read of a characteristic</li>
<li>setting the notification status of a characteristic</li>
</ul><h4>
<a name="hierarchical-operations-are-cool" class="anchor" href="#hierarchical-operations-are-cool"><span class="octicon octicon-link"></span></a>Hierarchical operations are cool.</h4>

<p>The data object hierachy of CoreBluetooth can be described as such:</p>

<ul>
<li>A CBCentralManager instance can connect to multiple CBPeripheral instances.

<ul>
<li>A CBPeripheral instance can have multiple CBService instances.

<ul>
<li>A CBService instance can have multiple CBCharacteristic instances.

<ul>
<li>A CBCharacteristic instance can have multiple CBDescriptor instances.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul><p>However the existing CoreBluetooth API does not map BLE requests to the data object hierarchy. For example connection to a CBPeripheral instance is accomplished from a CBCentralManager instance instead of from a CBPeripheral. Writes, reads, and setting the notification state of a CBCharacteristic are issued from a CBPeripheral instance, instead of from CBCharacteristic. <em>YmsCoreBluetooth provides an API that more naturally maps operations to the data object hierarchy</em>.</p>

<p>YMSCoreBluetooth defines container classes which map to the CoreBluetooth object hierarchy:</p>

<ul>
<li>YMSCBCentralManager - Contains a CBCentralManager instance.

<ul>
<li>YMSCBPeripheral - Contains a CBPeripheral instance.

<ul>
<li>YMSCBService - Contains a CBService instance.

<ul>
<li>YMSCBCharacteristic - Contains a CBCharacteristic instance.

<ul>
<li>YMSCBDescriptor - Contains a CBDescriptor instance.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul><p>However, they differ from CoreBluetooth in that operations are done with respect to the object type:</p>

<ul>
<li>YMSCBCentralManager

<ul>
<li>scans for peripherals</li>
<li>retrieves peripherals</li>
</ul>
</li>
<li>YMSCBPeripheral

<ul>
<li>connects and disconnects to central</li>
<li>discovers services associated with this peripheral</li>
</ul>
</li>
<li>YMSCBService

<ul>
<li>discovers characteristics associated with this service</li>
<li>handles notification updates for characteristics which are set to notify</li>
</ul>
</li>
<li>YMSCBCharacteristic

<ul>
<li>set notification status (on, off)</li>
<li>write value to characteristic</li>
<li>read value of characteristic</li>
<li>discover descriptors associated with this characteristic </li>
</ul>
</li>
<li>YMSCBDescriptor

<ul>
<li>write value to descriptor</li>
<li>read value of descriptor</li>
</ul>
</li>
</ul><h3>
<a name="show-code" class="anchor" href="#show-code"><span class="octicon octicon-link"></span></a>Show Code</h3>

<h4>
<a name="scanning-for-peripherals" class="anchor" href="#scanning-for-peripherals"><span class="octicon octicon-link"></span></a>Scanning for Peripherals</h4>

<p>In the following code sample, <code>self</code> is an instance of a subclass of YMSCBCentralManager.</p>

<pre><code>[self scanForPeripheralsWithServices:nil
                             options:options
                           withBlock:^(CBPeripheral *peripheral, NSDictionary *advertisementData, NSNumber *RSSI, NSError *error) {
                               if (error) {
                                   NSLog(@"Something bad happened with scanForPeripheralWithServices:options:withBlock:");
                                   return;
                               }

                               NSLog(@"DISCOVERED: %@, %@, %@ db", peripheral, peripheral.name, RSSI);
                               [this handleFoundPeripheral:peripheral];
                           }];
</code></pre>

<h4>
<a name="retrieving-peripherals" class="anchor" href="#retrieving-peripherals"><span class="octicon octicon-link"></span></a>Retrieving Peripherals</h4>

<p>In the following code sample, <code>self</code> is an instance of a subclass of YMSCBCentralManager.</p>

<pre><code>[self retrievePeripherals:peripheralUUIDs
                withBlock:^(CBPeripheral *peripheral) {
                    [this handleFoundPeripheral:peripheral];
                }];
</code></pre>

<h4>
<a name="connecting-to-a-peripheral" class="anchor" href="#connecting-to-a-peripheral"><span class="octicon octicon-link"></span></a>Connecting to a Peripheral</h4>

<p>In the following code sample, <code>self</code> is an instance of a subclass of YMSCBPeripheral. Note that in the callbacks, discovering services and characteristics are handled in a nested fashion:</p>

<pre><code>- (void)connect {
    // Watchdog aware method
    [self resetWatchdog];

    [self connectWithOptions:nil withBlock:^(YMSCBPeripheral *yp, NSError *error) {
        if (error) {
            return;
        }

        [yp discoverServices:[yp services] withBlock:^(NSArray *yservices, NSError *error) {
            if (error) {
                return;
            }

            for (YMSCBService *service in yservices) {
                __weak YMSCBService *thisService = (YMSCBService *)service;

                [service discoverCharacteristics:[service characteristics] withBlock:^(NSDictionary *chDict, NSError *error) {
                    if (error) {
                        return;
                    }

                    for (NSString *key in chDict) {
                        YMSCBCharacteristic *ct = chDict[key];
                        //NSLog(@"%@ %@ %@", ct, ct.cbCharacteristic, ct.uuid);

                        [ct discoverDescriptorsWithBlock:^(NSArray *ydescriptors, NSError *error) {
                            if (error) {
                                return;
                            }
                            for (YMSCBDescriptor *yd in ydescriptors) {
                                NSLog(@"Descriptor: %@ %@ %@", thisService.name, yd.UUID, yd.cbDescriptor);
                            }
                        }];
                    }
                }];
            }
        }];
    }];
}
</code></pre>

<h4>
<a name="read-a-characteristic" class="anchor" href="#read-a-characteristic"><span class="octicon octicon-link"></span></a>Read a Characteristic</h4>

<p>In the following code sample, <code>self</code> is an instance of a subclass of YMSCBService. All discovered characteristics are stored in [YMSCBService characteristicDict].</p>

<pre><code>- (void)readDeviceInfo {

    YMSCBCharacteristic *system_idCt = self.characteristicDict[@"system_id"];
    __weak DEADeviceInfoService *this = self;
    [system_idCt readValueWithBlock:^(NSData *data, NSError *error) {
        NSMutableString *tmpString = [NSMutableString stringWithFormat:@""];
        unsigned char bytes[data.length];
        [data getBytes:bytes];
        for (int ii = data.length; ii &gt;= 0;ii--) {
            [tmpString appendFormat:@"%02hhx",bytes[ii]];
            if (ii) {
                [tmpString appendFormat:@":"];
            }
        }

        NSLog(@"system id: %@", tmpString);
        this.system_id = tmpString;
    }];

    YMSCBCharacteristic *model_numberCt = self.characteristicDict[@"model_number"];
    [model_numberCt readValueWithBlock:^(NSData *data, NSError *error) {
        if (error) {
            NSLog(@"ERROR: %@", error);
            return;
        }

        NSString *payload = [[NSString alloc] initWithData:data encoding:NSStringEncodingConversionAllowLossy];
        this.model_number = payload;
        NSLog(@"model: %@", payload);

    }];
}
</code></pre>

<h4>
<a name="write-to-a-characteristic" class="anchor" href="#write-to-a-characteristic"><span class="octicon octicon-link"></span></a>Write to a Characteristic</h4>

<p>In the following code sample, <code>self</code> is an instance of a subclass of YMSCBService. In this example, a write to the 'config' characteristic followed by a read of the 'calibration' characteristic is done.</p>

<pre><code>- (void)requestCalibration {
    if (self.isCalibrating == NO) {

        __weak DEABarometerService *this = self;

        YMSCBCharacteristic *configCt = self.characteristicDict[@"config"];
        [configCt writeByte:0x2 withBlock:^(NSError *error) {
            if (error) {
                NSLog(@"ERROR: write request to barometer config to start calibration failed.");
                return;
            }

            YMSCBCharacteristic *calibrationCt = this.characteristicDict[@"calibration"];
            [calibrationCt readValueWithBlock:^(NSData *data, NSError *error) {
                if (error) {
                    NSLog(@"ERROR: read request to barometer calibration failed.");
                    return;
                }

                this.isCalibrating = NO;
                char val[data.length];
                [data getBytes:&amp;val length:data.length];

                int i = 0;
                while (i &lt; data.length) {
                    uint16_t lo = val[i];
                    uint16_t hi = val[i+1];
                    uint16_t cx = ((lo &amp; 0xff)| ((hi &lt;&lt; 8) &amp; 0xff00));
                    int index = i/2 + 1;

                    if (index == 1) self.c1 = cx;
                    else if (index == 2) this.c2 = cx;
                    else if (index == 3) this.c3 = cx;
                    else if (index == 4) this.c4 = cx;
                    else if (index == 5) this.c5 = cx;
                    else if (index == 6) this.c6 = cx;
                    else if (index == 7) this.c7 = cx;
                    else if (index == 8) this.c8 = cx;

                    i = i + 2;
                }

                this.isCalibrated = YES;

            }];
        }];

    }
}
</code></pre>

<h3>
<a name="handling-characteristic-notification-updates" class="anchor" href="#handling-characteristic-notification-updates"><span class="octicon octicon-link"></span></a>Handling Characteristic Notification Updates</h3>

<p>One place where YmsCoreBluetooth does <em>not</em> use blocks to handle BLE responses is with characteristic notification updates. The reason for this is because such updates are asynchronous and non-deterministic. As such the handler method [YMSCBService notifyCharacteristicHandler:error:] must be implemented for any subclass of YMSCBService to handle such updates.</p>

<p>In the following code sample, <code>self</code> is an instance of a subclass of YMSCBService. </p>

<pre><code>- (void)turnOn {
    __weak DEABaseService *this = self;
    YMSCBCharacteristic *configCt = self.characteristicDict[@"config"];
    [configCt writeByte:0x1 withBlock:^(NSError *error) {
        if (error) {
            NSLog(@"ERROR: %@", error);
            return;
        }

        NSLog(@"TURNED ON: %@", this.name);
    }];

    YMSCBCharacteristic *dataCt = self.characteristicDict[@"data"];
    [dataCt setNotifyValue:YES withBlock:^(NSError *error) {
        if (error) {
            return;
        }
        NSLog(@"Data notification for %@ on", this.name);
    }];

    self.isOn = YES;
}

- (void)notifyCharacteristicHandler:(YMSCBCharacteristic *)yc error:(NSError *)error {
    if (error) {
        return;
    }

    if ([yc.name isEqualToString:@"data"]) {
        NSData *data = yc.cbCharacteristic.value;
        char val[data.length];
        [data getBytes:&amp;val length:data.length];

        int16_t v0 = val[0];
        int16_t v1 = val[1];
        int16_t v2 = val[2];
        int16_t v3 = val[3];
        int16_t amb = ((v2 &amp; 0xff)| ((v3 &lt;&lt; 8) &amp; 0xff00));
        int16_t objT = ((v0 &amp; 0xff)| ((v1 &lt;&lt; 8) &amp; 0xff00));

        double tempAmb = calcTmpLocal(amb);

        self.ambientTemp = [NSNumber numberWithDouble:tempAmb];
        self.objectTemp = [NSNumber numberWithDouble:calcTmpTarget(objT, tempAmb)];
    }
}
</code></pre>

<h3>
<a name="block-callback-design" class="anchor" href="#block-callback-design"><span class="octicon octicon-link"></span></a>Block Callback Design</h3>

<p>The callback pattern used by YmsCoreBluetooth uses a single callback to handle both successfull and failed responses. This is accomplished by including an <code>error</code> parameter. If an <code>error</code> object is not <code>nil</code>, then behavior to handle the failure can be implemented. Otherwise behavior to handle success is implemented.</p>

<pre><code>^(NSError *error) {
   if (error) {
      // Code to handle failure
      return;
   }
   // Code to handle success
}
</code></pre>

<h2>
<a name="file-naming-conventions" class="anchor" href="#file-naming-conventions"><span class="octicon octicon-link"></span></a>File Naming Conventions</h2>

<p>The YmsCoreBluetooth framework is the set of files prefixed with <code>YMSCB</code> located in the directory <code>YmsCoreBluetooth</code>.</p>

<p>The files for the iOS application <strong>Deanna</strong> are prefixed with <code>DEA</code> and are located in the directory <code>Deanna</code>.</p>

<p>The files for the OS X application <strong>DeannaMac</strong> are prefixed with <code>DEM</code> and are located in the directory <code>DeannaMac</code>.</p>

<h2>
<a name="recommended-code-walk-through" class="anchor" href="#recommended-code-walk-through"><span class="octicon octicon-link"></span></a>Recommended Code Walk Through</h2>

<p>To better understand how YmsCoreBluetooth works, it is recommended to first read the source of the following BLE service implementations:</p>

<ul>
<li>DEAAccelerometerService, DEABarometerService, DEAGyroscopeService, DEAHumidityService, DEAMagnetometerService, DEASimpleKeysService, DEATemperatureService, DEADeviceInfoService</li>
</ul><p>Then the BLE peripheral implementation of the TI SensorTag:</p>

<ul>
<li>DEASensorTag</li>
</ul><p>Then the application service which manages all known peripherals:</p>

<ul>
<li>DEACentralManager</li>
</ul><p>The <a href="http://kickingvegas.github.io/YmsCoreBluetooth/appledoc/hierarchy.html">Class Hierarchy</a> is very instructive in showing the relationship of the above classes to the YmsCoreBluetooth framework.</p>

<h2>
<a name="writing-your-own-bluetooth-le-service-with-ymscorebluetooth" class="anchor" href="#writing-your-own-bluetooth-le-service-with-ymscorebluetooth"><span class="octicon octicon-link"></span></a>Writing your own Bluetooth LE service with YmsCoreBluetooth</h2>

<p>Learn how to write your own Bluetooth LE service by reading the example of how its done for the TI SensorTag in the <a href="http://kickingvegas.github.io/YmsCoreBluetooth/appledoc/docs/tutorial/Tutorial.html">Tutorial</a>.</p>

<h2>
<a name="questions" class="anchor" href="#questions"><span class="octicon octicon-link"></span></a>Questions</h2>

<p>While quite functional, YmsCoreBluetooth is still very much in an early state and there's always room for improvement. Please submit any questions or <a href="https://github.com/kickingvegas/YmsCoreBluetooth/issues?labels=&amp;milestone=&amp;page=1&amp;state=open">issues to the GitHub project for YmsCoreBluetooth</a>.</p>

<h2>
<a name="notes" class="anchor" href="#notes"><span class="octicon octicon-link"></span></a>Notes</h2>

<p>Code tested on:</p>

<ul>
<li>iPhone 4S, iOS 6.1.3</li>
<li>TI SensorTag firmware 1.2, 1.3.</li>
<li>iMac 27 Mid-2010, OS X 10.8.3</li>
</ul><h2>
<a name="known-issues" class="anchor" href="#known-issues"><span class="octicon octicon-link"></span></a>Known Issues</h2>

<ul>
<li>No support is offered for the iOS simulator due to the instability of the CoreBluetooth implementation on it. Use this code only on iOS hardware that supports CoreBluetooth. Given that Apple does not provide technical support for CoreBluetooth behavior on the iOS simulator <a href="http://developer.apple.com/library/ios/#technotes/tn2295/_index.html">TN2295</a>, I feel this is a reasonable position to take. Hopefully in time the iOS simulator will exhibit better CoreBluetooth fidelity.</li>
</ul><h2>
<a name="latest-changes" class="anchor" href="#latest-changes"><span class="octicon octicon-link"></span></a>Latest Changes</h2>

<h3>
<a name="mon-jun-3-2013---disco-release-ver-094" class="anchor" href="#mon-jun-3-2013---disco-release-ver-094"><span class="octicon octicon-link"></span></a>Mon Jun 3 2013 - Disco Release (ver 0.94)</h3>

<ul>
<li>Issue #9 - OS X Support</li>
</ul><p>YmsCoreBluetooth now supports OS X! Includes app target DeannaMac which replicates functionality found in Deanna for iOS.</p>

<p>Tested Mac Environment:</p>

<ul>
<li>OS X 10.8.3</li>
<li>Cirago Bluetooth 4.0 USB Adapter</li>
<li>iMac 27 Mid-2010</li>
</ul><h3>
<a name="sun-may-26-2013---rare-groove-release-ver-093" class="anchor" href="#sun-may-26-2013---rare-groove-release-ver-093"><span class="octicon octicon-link"></span></a>Sun May 26 2013 - Rare Groove Release (ver 0.93)</h3>

<ul>
<li>
<p>Issue #47 - rename YMSCBAppService to YMSCBCentralManager. 
Associated changes include:</p>

<ul>
<li>renaming DEAAppService to DEACentralManager</li>
<li>rename variable cbAppService to centralManager</li>
</ul>
</li>
<li><p>API change to fully embrace ObjectiveC block-based callbacks.</p></li>
<li><p>API change to map BLE operations to data object hierarchy.</p></li>
</ul><p><strong>API 0.93 is a BIG CHANGE.</strong> It is largely a rethink of YmsCoreBluetooth to support the pattern for hierarchical block-based operations. This will very much <em>break code</em> written for prior releases of YmsCoreBluetooth. That said, the changes should be fairly comprehensible and address the following points going forward:</p>

<ul>
<li>Improved understanding of API behavior; prior releases had too much implicit behavior ("magic") which made involuntary decisions for the developer using the API. Using blocks gives the developer a clearer and more structured view of the BLE transactions to be made.</li>
<li>With the pattern for hierarchical block-based operations in place, a more structured way to add new API features. <del>Like Winter, characteristic descriptors are coming.</del> <a href="https://github.com/kickingvegas/YmsCoreBluetooth/blob/master/YmsCoreBluetooth/YMSCBDescriptor.h">Descriptor</a> support is in!</li>
</ul><p>View <a href="https://github.com/kickingvegas/YmsCoreBluetooth/blob/master/CHANGES.md">Prior Change List</a></p>

<h3>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h3>

<pre><code>Copyright 2013 Yummy Melon Software LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Author: Charles Y. Choi &lt;charles.choi@yummymelon.com&gt;
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">YmsCoreBluetooth maintained by <a href="https://github.com/kickingvegas">kickingvegas</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-9829097-6");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
