{"name":"YmsCoreBluetooth","tagline":"A block-based framework for building Bluetooth 4.0 Low Energy (aka Smart or LE) iOS or OS X applications using the CoreBluetooth API. Includes Deanna and DeannaMac, applications to communicate with a Texas Instruments SensorTag.","body":"# YmsCoreBluetooth v0.946 (beta)\r\nA block-based framework for building Bluetooth 4.0 Low Energy (aka Smart or LE) iOS or OS X applications using the CoreBluetooth API. Includes *Deanna* and *DeannaMac*, applications to communicate with a [TI SensorTag](http://processors.wiki.ti.com/index.php/Bluetooth_SensorTag) for iOS and OS X respectively.\r\n\r\n* [YmsCoreBluetooth API Reference](http://kickingvegas.github.io/YmsCoreBluetooth/appledoc/index.html)\r\n\r\n## YmsCoreBluetooth Design Intent: Or Why You Want To Use This Framework\r\n### tl;dr \r\n* ObjectiveC Block-based API for Bluetooth LE communication.\r\n* Operations (e.g. scanning, retrieval, connection, reads, writes) map to the data object hierarchy of CoreBluetooth.\r\n* You can build apps using CoreBluetooth [faster](http://yummymelon.com/ymsblog/sensortag-remote-control-for-itunes.html).\r\n\r\n### A More Detailed Explanation\r\n\r\n#### Blocks are cool.\r\nTransactions in Bluetooth LE (BLE) are two-phase (request-response) in nature: CoreBluetooth abstracts this protocol so that request behavior is separated from response behavior. The two phases are reconciled using a delegation pattern: the object initiating the request phase has a delegate object with a delegate method to handle the corresponding response phase. While functional, the delegation pattern can be cumbersome to use because the behavior for a two-phase transaction is split into two different locations in code.\r\n\r\nA more convenient programming pattern is to use a callback block which is defined with the request. When the response is received, the callback block can be executed to handle it. *The design intent of YmsCoreBluetooth is use Objective-C blocks to define response behavior to BLE requests*. Such requests include:\r\n\r\n* scanning and/or retrieving peripheral(s)\r\n* connecting to a peripheral\r\n* discovering a peripheral's services\r\n* discovering a service's characteristics\r\n* write and read of a characteristic\r\n* setting the notification status of a characteristic\r\n\r\n#### Hierarchical operations are cool.\r\nThe data object hierachy of CoreBluetooth can be described as such:\r\n\r\n* A CBCentralManager instance can connect to multiple CBPeripheral instances.\r\n    * A CBPeripheral instance can have multiple CBService instances.\r\n\t    * A CBService instance can have multiple CBCharacteristic instances.\r\n\t\t    * A CBCharacteristic instance can have multiple CBDescriptor instances.\r\n\t\t\t\r\nHowever the existing CoreBluetooth API does not map BLE requests to the data object hierarchy. For example connection to a CBPeripheral instance is accomplished from a CBCentralManager instance instead of from a CBPeripheral. Writes, reads, and setting the notification state of a CBCharacteristic are issued from a CBPeripheral instance, instead of from CBCharacteristic. *YmsCoreBluetooth provides an API that more naturally maps operations to the data object hierarchy*.\r\n\r\nYMSCoreBluetooth defines container classes which map to the CoreBluetooth object hierarchy:\r\n\r\n* YMSCBCentralManager - Contains a CBCentralManager instance.\r\n    * YMSCBPeripheral - Contains a CBPeripheral instance.\r\n        * YMSCBService - Contains a CBService instance.\r\n             * YMSCBCharacteristic - Contains a CBCharacteristic instance.\r\n\t\t\t     * YMSCBDescriptor - Contains a CBDescriptor instance.\r\n\r\nHowever, they differ from CoreBluetooth in that operations are done with respect to the object type:\r\n\r\n* YMSCBCentralManager\r\n  - scans for peripherals\r\n  - retrieves peripherals\r\n* YMSCBPeripheral\r\n  - connects and disconnects to central\r\n  - discovers services associated with this peripheral\r\n* YMSCBService\r\n  - discovers characteristics associated with this service\r\n  - handles notification updates for characteristics which are set to notify\r\n* YMSCBCharacteristic\r\n  - set notification status (on, off)\r\n  - write value to characteristic\r\n  - read value of characteristic\r\n  - discover descriptors associated with this characteristic \r\n* YMSCBDescriptor\r\n  - write value to descriptor\r\n  - read value of descriptor\r\n\r\n### Deanna and DeannaMac\r\n\r\nThe apps **Deanna** and **DeannaMac** are demonstration apps intended to illustrate the use of *YmsCoreBluetooth*. Both apps use *YmsCoreBluetooth* to characterize a TI SensorTag and provide controllability and observability of the six sensors on the device. It also has the capability to scan for other BLE devices.\r\n\r\n*Deanna* has been recently changed (v 0.943) to support the graphic design contributions of [Wayne Dahlberg](http://waynedahlberg.com). \r\n\r\n### Show Code\r\n#### Scanning for Peripherals\r\n\r\nIn the following code sample, `self` is an instance of a subclass of YMSCBCentralManager.\r\n\r\n    __weak DEACentralManager *this = self;\r\n    [self scanForPeripheralsWithServices:nil\r\n                                 options:options\r\n                               withBlock:^(CBPeripheral *peripheral, NSDictionary *advertisementData, NSNumber *RSSI, NSError *error) {\r\n                                   if (error) {\r\n                                       NSLog(@\"Something bad happened with scanForPeripheralWithServices:options:withBlock:\");\r\n                                       return;\r\n                                   }\r\n                                   \r\n                                   NSLog(@\"DISCOVERED: %@, %@, %@ db\", peripheral, peripheral.name, RSSI);\r\n                                   [this handleFoundPeripheral:peripheral];\r\n                               }];\r\n\r\n#### Retrieving Peripherals\r\n\r\nIn the following code sample, `self` is an instance of a subclass of YMSCBCentralManager.\r\n\r\n\t__weak DEACentralManager *this = self;\r\n\t[self retrievePeripherals:peripheralUUIDs\r\n\t\t\t\t\twithBlock:^(CBPeripheral *peripheral) {\r\n\t\t\t\t\t\t[this handleFoundPeripheral:peripheral];\r\n\t\t\t\t\t}];\r\n  \r\n  \r\n#### Connecting to a Peripheral\r\n\r\nIn the following code sample, `self` is an instance of a subclass of YMSCBPeripheral. Note that in the callbacks, discovering services and characteristics are handled in a nested fashion:\r\n\r\n\t- (void)connect {\r\n\t\t// Watchdog aware method\r\n\t\t[self resetWatchdog];\r\n\r\n\t\t[self connectWithOptions:nil withBlock:^(YMSCBPeripheral *yp, NSError *error) {\r\n\t\t\tif (error) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t[yp discoverServices:[yp services] withBlock:^(NSArray *yservices, NSError *error) {\r\n\t\t\t\tif (error) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (YMSCBService *service in yservices) {\r\n\t\t\t\t\tif ([service.name isEqualToString:@\"simplekeys\"]) {\r\n\t\t\t\t\t\t__weak DEASimpleKeysService *thisService = (DEASimpleKeysService *)service;\r\n\t\t\t\t\t\t[service discoverCharacteristics:[service characteristics] withBlock:^(NSDictionary *chDict, NSError *error) {\r\n\t\t\t\t\t\t\t[thisService turnOn];\r\n\t\t\t\t\t\t}];\r\n\r\n\t\t\t\t\t} else if ([service.name isEqualToString:@\"devinfo\"]) {\r\n\t\t\t\t\t\t__weak DEADeviceInfoService *thisService = (DEADeviceInfoService *)service;\r\n\t\t\t\t\t\t[service discoverCharacteristics:[service characteristics] withBlock:^(NSDictionary *chDict, NSError *error) {\r\n\t\t\t\t\t\t\t[thisService readDeviceInfo];\r\n\t\t\t\t\t\t}];\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t__weak DEABaseService *thisService = (DEABaseService *)service;\r\n\t\t\t\t\t\t[service discoverCharacteristics:[service characteristics] withBlock:^(NSDictionary *chDict, NSError *error) {\r\n\t\t\t\t\t\t\tfor (NSString *key in chDict) {\r\n\t\t\t\t\t\t\t\tYMSCBCharacteristic *ct = chDict[key];\r\n\t\t\t\t\t\t\t\t//NSLog(@\"%@ %@ %@\", ct, ct.cbCharacteristic, ct.uuid);\r\n\r\n\t\t\t\t\t\t\t\t[ct discoverDescriptorsWithBlock:^(NSArray *ydescriptors, NSError *error) {\r\n\t\t\t\t\t\t\t\t\tif (error) {\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tfor (YMSCBDescriptor *yd in ydescriptors) {\r\n\t\t\t\t\t\t\t\t\t\tNSLog(@\"Descriptor: %@ %@ %@\", thisService.name, yd.UUID, yd.cbDescriptor);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}];\r\n\t\t}];\r\n\t}\r\n\r\n\r\n#### Read a Characteristic\r\n\r\nIn the following code sample, `self` is an instance of a subclass of YMSCBService. All discovered characteristics are stored in [YMSCBService characteristicDict].\r\n\r\n\t- (void)readDeviceInfo {\r\n\r\n\t\tYMSCBCharacteristic *system_idCt = self.characteristicDict[@\"system_id\"];\r\n\t\t__weak DEADeviceInfoService *this = self;\r\n\t\t[system_idCt readValueWithBlock:^(NSData *data, NSError *error) {\r\n\t\t\tNSMutableString *tmpString = [NSMutableString stringWithFormat:@\"\"];\r\n\t\t\tunsigned char bytes[data.length];\r\n\t\t\t[data getBytes:bytes];\r\n\t\t\tfor (int ii = (int)data.length; ii >= 0;ii--) {\r\n\t\t\t\t[tmpString appendFormat:@\"%02hhx\",bytes[ii]];\r\n\t\t\t\tif (ii) {\r\n\t\t\t\t\t[tmpString appendFormat:@\":\"];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tNSLog(@\"system id: %@\", tmpString);\r\n\t\t\t_YMS_PERFORM_ON_MAIN_THREAD(^{\r\n\t\t\t\tthis.system_id = tmpString;\r\n\t\t\t});\r\n\r\n\t\t}];\r\n\r\n\t\tYMSCBCharacteristic *model_numberCt = self.characteristicDict[@\"model_number\"];\r\n\t\t[model_numberCt readValueWithBlock:^(NSData *data, NSError *error) {\r\n\t\t\tif (error) {\r\n\t\t\t\tNSLog(@\"ERROR: %@\", error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tNSString *payload = [[NSString alloc] initWithData:data encoding:NSStringEncodingConversionAllowLossy];\r\n\t\t\tNSLog(@\"model number: %@\", payload);\r\n\t\t\t_YMS_PERFORM_ON_MAIN_THREAD(^{\r\n\t\t\t\tthis.model_number = payload;\r\n\t\t\t});\r\n\t\t}];\r\n\t}\r\n\r\n\r\n#### Write to a Characteristic\r\n\r\nIn the following code sample, `self` is an instance of a subclass of YMSCBService. In this example, a write to the 'config' characteristic followed by a read of the 'calibration' characteristic is done.\r\n\r\n\t- (void)requestCalibration {\r\n\t\tif (self.isCalibrating == NO) {\r\n\r\n\t\t\t__weak DEABarometerService *this = self;\r\n\r\n\t\t\tYMSCBCharacteristic *configCt = self.characteristicDict[@\"config\"];\r\n\t\t\t[configCt writeByte:0x2 withBlock:^(NSError *error) {\r\n\t\t\t\tif (error) {\r\n\t\t\t\t\tNSLog(@\"ERROR: write request to barometer config to start calibration failed.\");\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tYMSCBCharacteristic *calibrationCt = this.characteristicDict[@\"calibration\"];\r\n\t\t\t\t[calibrationCt readValueWithBlock:^(NSData *data, NSError *error) {\r\n\t\t\t\t\tif (error) {\r\n\t\t\t\t\t\tNSLog(@\"ERROR: read request to barometer calibration failed.\");\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.isCalibrating = NO;\r\n\t\t\t\t\tchar val[data.length];\r\n\t\t\t\t\t[data getBytes:&val length:data.length];\r\n\r\n\t\t\t\t\tint i = 0;\r\n\t\t\t\t\twhile (i < data.length) {\r\n\t\t\t\t\t\tuint16_t lo = val[i];\r\n\t\t\t\t\t\tuint16_t hi = val[i+1];\r\n\t\t\t\t\t\tuint16_t cx = ((lo & 0xff)| ((hi << 8) & 0xff00));\r\n\t\t\t\t\t\tint index = i/2 + 1;\r\n\r\n\t\t\t\t\t\tif (index == 1) self.c1 = cx;\r\n\t\t\t\t\t\telse if (index == 2) this.c2 = cx;\r\n\t\t\t\t\t\telse if (index == 3) this.c3 = cx;\r\n\t\t\t\t\t\telse if (index == 4) this.c4 = cx;\r\n\t\t\t\t\t\telse if (index == 5) this.c5 = cx;\r\n\t\t\t\t\t\telse if (index == 6) this.c6 = cx;\r\n\t\t\t\t\t\telse if (index == 7) this.c7 = cx;\r\n\t\t\t\t\t\telse if (index == 8) this.c8 = cx;\r\n\r\n\t\t\t\t\t\ti = i + 2;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.isCalibrating = YES;\r\n\t\t\t\t\tthis.isCalibrated = YES;\r\n\r\n\t\t\t\t}];\r\n\t\t\t}];\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n### Handling Characteristic Notification Updates\r\n\r\nOne place where YmsCoreBluetooth does *not* use blocks to handle BLE responses is with characteristic notification updates. The reason for this is because such updates are asynchronous and non-deterministic. As such the handler method `[YMSCBService notifyCharacteristicHandler:error:]` must be implemented for any subclass of YMSCBService to handle such updates.\r\n\r\nIn the following code sample, `self` is an instance of a subclass of YMSCBService.\r\n\r\n\t- (void)turnOn {\r\n\t\t__weak DEABaseService *this = self;\r\n\r\n\t\tYMSCBCharacteristic *configCt = self.characteristicDict[@\"config\"];\r\n\t\t[configCt writeByte:0x1 withBlock:^(NSError *error) {\r\n\t\t\tif (error) {\r\n\t\t\t\tNSLog(@\"ERROR: %@\", error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tNSLog(@\"TURNED ON: %@\", this.name);\r\n\t\t}];\r\n\r\n\t\tYMSCBCharacteristic *dataCt = self.characteristicDict[@\"data\"];\r\n\t\t[dataCt setNotifyValue:YES withBlock:^(NSError *error) {\r\n\t\t\tNSLog(@\"Data notification for %@ on\", this.name);\r\n\t\t}];\r\n\r\n\r\n\t\t_YMS_PERFORM_ON_MAIN_THREAD(^{\r\n\t\t\tthis.isOn = YES;\r\n\t\t});\r\n\t}\r\n\r\n\t- (void)notifyCharacteristicHandler:(YMSCBCharacteristic *)yc error:(NSError *)error {\r\n\t\tif (error) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ([yc.name isEqualToString:@\"data\"]) {\r\n\t\t\tNSData *data = yc.cbCharacteristic.value;\r\n\r\n\t\t\tchar val[data.length];\r\n\t\t\t[data getBytes:&val length:data.length];\r\n\r\n\t\t\tint16_t v0 = val[0];\r\n\t\t\tint16_t v1 = val[1];\r\n\t\t\tint16_t v2 = val[2];\r\n\t\t\tint16_t v3 = val[3];\r\n\r\n\t\t\tint16_t amb = ((v2 & 0xff)| ((v3 << 8) & 0xff00));\r\n\t\t\tint16_t objT = ((v0 & 0xff)| ((v1 << 8) & 0xff00));\r\n\r\n\t\t\tdouble tempAmb = calcTmpLocal(amb);\r\n\r\n\t\t\t__weak DEATemperatureService *this = self;\r\n\t\t\t_YMS_PERFORM_ON_MAIN_THREAD(^{\r\n\t\t\t\tthis.ambientTemp = @(tempAmb);\r\n\t\t\t\tthis.objectTemp = @(calcTmpTarget(objT, tempAmb));\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\r\n** Important **: To let the UI components in the main thread know via KVO that a property has changed, you must update that property on the main thread. A convenience macro `_YMS_PERFORM_ON_MAIN_THREAD` which uses the GCD call `dispatch_async()` does just that:\r\n\r\n\t#define _YMS_PERFORM_ON_MAIN_THREAD(block) dispatch_async(dispatch_get_main_queue(), block);\r\n\r\n\r\n### Block Callback Design\r\n\r\nThe callback pattern used by YmsCoreBluetooth uses a single callback to handle both successfull and failed responses. This is accomplished by including an `error` parameter. If an `error` object is not `nil`, then behavior to handle the failure can be implemented. Otherwise behavior to handle success is implemented.\r\n\r\n\t^(NSError *error) {\r\n\t   if (error) {\r\n\t\t  // Code to handle failure\r\n\t\t  return;\r\n\t   }\r\n\t   // Code to handle success\r\n\t}\r\n\r\n\r\n## File Naming Conventions\r\nThe YmsCoreBluetooth framework is the set of files prefixed with `YMSCB` located in the directory `YmsCoreBluetooth`.\r\n\r\nThe files for the iOS application **Deanna** are prefixed with `DEA` and are located in the directory `Deanna`.\r\n\r\nThe files for the OS X application **DeannaMac** are prefixed with `DEM` and are located in the directory `DeannaMac`.\r\n\r\n## Recommended Code Walk Through\r\n\r\nTo better understand how YmsCoreBluetooth works, it is recommended to first read the source of the following BLE service implementations:\r\n\r\n* DEAAccelerometerService, DEABarometerService, DEAGyroscopeService, DEAHumidityService, DEAMagnetometerService, DEASimpleKeysService, DEATemperatureService, DEADeviceInfoService\r\n\r\nThen the BLE peripheral implementation of the TI SensorTag:\r\n\r\n* DEASensorTag\r\n\r\nThen the application service which manages all known peripherals:\r\n\r\n* DEACentralManager\r\n\r\nThe [Class Hierarchy](http://kickingvegas.github.io/YmsCoreBluetooth/appledoc/hierarchy.html) is very instructive in showing the relationship of the above classes to the YmsCoreBluetooth framework.\r\n\r\n\r\n## Writing your own Bluetooth LE service with YmsCoreBluetooth\r\n\r\nLearn how to write your own Bluetooth LE service by reading the example of how its done for the TI SensorTag in the [Tutorial](http://kickingvegas.github.io/YmsCoreBluetooth/appledoc/docs/tutorial/Tutorial.html).\r\n\r\n## Questions\r\n\r\nWhile quite functional, YmsCoreBluetooth is still very much in an early state and there's always room for improvement. Please submit any questions or [issues to the GitHub project for YmsCoreBluetooth](https://github.com/kickingvegas/YmsCoreBluetooth/issues?labels=&milestone=&page=1&state=open).\r\n\r\n\r\n## Notes\r\n\r\nCode tested on:\r\n\r\n* iPhone 4S, iOS 6.1.3\r\n* TI SensorTag firmware 1.2, 1.3.\r\n* iMac 27 Mid-2010, OS X 10.8.3\r\n\r\n## Known Issues\r\n* No support is offered for the iOS simulator due to the instability of the CoreBluetooth implementation on it. Use this code only on iOS hardware that supports CoreBluetooth. Given that Apple does not provide technical support for CoreBluetooth behavior on the iOS simulator [TN2295](http://developer.apple.com/library/ios/#technotes/tn2295/_index.html), I feel this is a reasonable position to take. Hopefully in time the iOS simulator will exhibit better CoreBluetooth fidelity.\r\n\r\n## Latest Changes\r\n### Sat Sep 7 2013 - Interim Release (ver 0.946)\r\n* #25 - Support for accelerometer period\r\n* #73 - Fix declaration of block properties to copy\r\n\r\n### Tue Jul 16 2013 - Interim Release (ver 0.945)\r\n* Bugfix #61 - Change all delegate implementations so that the callback is performed on the main thread.\r\n\r\n### Sat Jul 6 2013 - Interim Release (ver 0.944)\r\n* Bugfix #69 - Reload peripheralsTableView when dismissing SensorTag view controller\r\n* Bugfix #68 - Handle CoreBluetooth XPC reset\r\n* Issue #32 - Added interim icon design by Wayne Dahlberg\r\n\r\n### Mon Jun 24 2013 - Interim Release (ver 0.943)\r\n* Initial work on beautifying Deanna app (Issue #62) based on graphic design work by [Wayne Dahlberg](http://waynedahlberg.com).\r\n* Fixes to updates of RSSI values via scanning or by connection.\r\n\r\n\r\nTested Mac Environment:\r\n\r\n* OS X 10.8.3\r\n* Cirago Bluetooth 4.0 USB Adapter\r\n* iMac 27 Mid-2010\r\n\r\n\r\nView [Prior Change List](https://github.com/kickingvegas/YmsCoreBluetooth/blob/master/CHANGES.md)\r\n\r\n\r\n### License\r\n\r\n    Copyright 2013 Yummy Melon Software LLC\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n    Author: Charles Y. Choi <charles.choi@yummymelon.com>\r\n\r\n\r\n\r\n\r\n\r\n","google":"UA-9829097-6","note":"Don't delete this file! It's used internally to help with page regeneration."}